// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"

	math_bits "math/bits"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Status is the components status
type Status int32

const (
	Down    Status = 0
	Up      Status = 1
	Unknown Status = 2
)

var Status_name = map[int32]string{
	0: "Down",
	1: "Up",
	2: "Unknown",
}

var Status_value = map[string]int32{
	"Down":    0,
	"Up":      1,
	"Unknown": 2,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}

// CircuitStatus is the circuit breaker status
type CircuitStatus int32

const (
	Open  CircuitStatus = 0
	Half  CircuitStatus = 1
	Close CircuitStatus = 2
)

var CircuitStatus_name = map[int32]string{
	0: "Open",
	1: "Half",
	2: "Close",
}

var CircuitStatus_value = map[string]int32{
	"Open":  0,
	"Half":  1,
	"Close": 2,
}

func (x CircuitStatus) Enum() *CircuitStatus {
	p := new(CircuitStatus)
	*p = x
	return p
}

func (x CircuitStatus) String() string {
	return proto.EnumName(CircuitStatus_name, int32(x))
}

func (x *CircuitStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CircuitStatus_value, data, "CircuitStatus")
	if err != nil {
		return err
	}
	*x = CircuitStatus(value)
	return nil
}

func (CircuitStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}

// LoadBalance the load balance enum
type LoadBalance int32

const (
	RoundRobin LoadBalance = 0
	IPHash     LoadBalance = 1
	WightRobin LoadBalance = 2
	Rand       LoadBalance = 3
)

var LoadBalance_name = map[int32]string{
	0: "RoundRobin",
	1: "IPHash",
	2: "WightRobin",
	3: "Rand",
}

var LoadBalance_value = map[string]int32{
	"RoundRobin": 0,
	"IPHash":     1,
	"WightRobin": 2,
	"Rand":       3,
}

func (x LoadBalance) Enum() *LoadBalance {
	p := new(LoadBalance)
	*p = x
	return p
}

func (x LoadBalance) String() string {
	return proto.EnumName(LoadBalance_name, int32(x))
}

func (x *LoadBalance) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LoadBalance_value, data, "LoadBalance")
	if err != nil {
		return err
	}
	*x = LoadBalance(value)
	return nil
}

func (LoadBalance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}

// Protocol is the protocol of the backend api
type Protocol int32

const (
	HTTP        Protocol = 0
	Grpc        Protocol = 1
	Dubbo       Protocol = 2
	SpringCloud Protocol = 3
)

var Protocol_name = map[int32]string{
	0: "HTTP",
	1: "Grpc",
	2: "Dubbo",
	3: "SpringCloud",
}

var Protocol_value = map[string]int32{
	"HTTP":        0,
	"Grpc":        1,
	"Dubbo":       2,
	"SpringCloud": 3,
}

func (x Protocol) Enum() *Protocol {
	p := new(Protocol)
	*p = x
	return p
}

func (x Protocol) String() string {
	return proto.EnumName(Protocol_name, int32(x))
}

func (x *Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Protocol_value, data, "Protocol")
	if err != nil {
		return err
	}
	*x = Protocol(value)
	return nil
}

func (Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}

type Source int32

const (
	QueryString Source = 0
	FormData    Source = 1
	JSONBody    Source = 2
	Header      Source = 3
	Cookie      Source = 4
	PathValue   Source = 5
)

var Source_name = map[int32]string{
	0: "QueryString",
	1: "FormData",
	2: "JSONBody",
	3: "Header",
	4: "Cookie",
	5: "PathValue",
}

var Source_value = map[string]int32{
	"QueryString": 0,
	"FormData":    1,
	"JSONBody":    2,
	"Header":      3,
	"Cookie":      4,
	"PathValue":   5,
}

func (x Source) Enum() *Source {
	p := new(Source)
	*p = x
	return p
}

func (x Source) String() string {
	return proto.EnumName(Source_name, int32(x))
}

func (x *Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Source_value, data, "Source")
	if err != nil {
		return err
	}
	*x = Source(value)
	return nil
}

func (Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}

type RuleType int32

const (
	RuleRegexp RuleType = 0
)

var RuleType_name = map[int32]string{
	0: "RuleRegexp",
}

var RuleType_value = map[string]int32{
	"RuleRegexp": 0,
}

func (x RuleType) Enum() *RuleType {
	p := new(RuleType)
	*p = x
	return p
}

func (x RuleType) String() string {
	return proto.EnumName(RuleType_name, int32(x))
}

func (x *RuleType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RuleType_value, data, "RuleType")
	if err != nil {
		return err
	}
	*x = RuleType(value)
	return nil
}

func (RuleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}

type CMP int32

const (
	CMPEQ    CMP = 0
	CMPLT    CMP = 1
	CMPLE    CMP = 2
	CMPGT    CMP = 3
	CMPGE    CMP = 4
	CMPIn    CMP = 5
	CMPMatch CMP = 6
)

var CMP_name = map[int32]string{
	0: "CMPEQ",
	1: "CMPLT",
	2: "CMPLE",
	3: "CMPGT",
	4: "CMPGE",
	5: "CMPIn",
	6: "CMPMatch",
}

var CMP_value = map[string]int32{
	"CMPEQ":    0,
	"CMPLT":    1,
	"CMPLE":    2,
	"CMPGT":    3,
	"CMPGE":    4,
	"CMPIn":    5,
	"CMPMatch": 6,
}

func (x CMP) Enum() *CMP {
	p := new(CMP)
	*p = x
	return p
}

func (x CMP) String() string {
	return proto.EnumName(CMP_name, int32(x))
}

func (x *CMP) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMP_value, data, "CMP")
	if err != nil {
		return err
	}
	*x = CMP(value)
	return nil
}

func (CMP) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}

type RoutingStrategy int32

const (
	Copy  RoutingStrategy = 0
	Split RoutingStrategy = 1
)

var RoutingStrategy_name = map[int32]string{
	0: "Copy",
	1: "Split",
}

var RoutingStrategy_value = map[string]int32{
	"Copy":  0,
	"Split": 1,
}

func (x RoutingStrategy) Enum() *RoutingStrategy {
	p := new(RoutingStrategy)
	*p = x
	return p
}

func (x RoutingStrategy) String() string {
	return proto.EnumName(RoutingStrategy_name, int32(x))
}

func (x *RoutingStrategy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RoutingStrategy_value, data, "RoutingStrategy")
	if err != nil {
		return err
	}
	*x = RoutingStrategy(value)
	return nil
}

func (RoutingStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}

type MatchRule int32

const (
	MatchDefault MatchRule = 0
	MatchAll     MatchRule = 1
	MatchAny     MatchRule = 2
)

var MatchRule_name = map[int32]string{
	0: "MatchDefault",
	1: "MatchAll",
	2: "MatchAny",
}

var MatchRule_value = map[string]int32{
	"MatchDefault": 0,
	"MatchAll":     1,
	"MatchAny":     2,
}

func (x MatchRule) Enum() *MatchRule {
	p := new(MatchRule)
	*p = x
	return p
}

func (x MatchRule) String() string {
	return proto.EnumName(MatchRule_name, int32(x))
}

func (x *MatchRule) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MatchRule_value, data, "MatchRule")
	if err != nil {
		return err
	}
	*x = MatchRule(value)
	return nil
}

func (MatchRule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}

type HostType int32

const (
	HostOrigin        HostType = 0
	HostServerAddress HostType = 1
	HostCustom        HostType = 2
)

var HostType_name = map[int32]string{
	0: "HostOrigin",
	1: "HostServerAddress",
	2: "HostCustom",
}

var HostType_value = map[string]int32{
	"HostOrigin":        0,
	"HostServerAddress": 1,
	"HostCustom":        2,
}

func (x HostType) Enum() *HostType {
	p := new(HostType)
	*p = x
	return p
}

func (x HostType) String() string {
	return proto.EnumName(HostType_name, int32(x))
}

func (x *HostType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HostType_value, data, "HostType")
	if err != nil {
		return err
	}
	*x = HostType(value)
	return nil
}

func (HostType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}

type RateLimitOption int32

const (
	Wait   RateLimitOption = 0
	Reject RateLimitOption = 1
)

var RateLimitOption_name = map[int32]string{
	0: "Wait",
	1: "Reject",
}

var RateLimitOption_value = map[string]int32{
	"Wait":   0,
	"Reject": 1,
}

func (x RateLimitOption) Enum() *RateLimitOption {
	p := new(RateLimitOption)
	*p = x
	return p
}

func (x RateLimitOption) String() string {
	return proto.EnumName(RateLimitOption_name, int32(x))
}

func (x *RateLimitOption) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RateLimitOption_value, data, "RateLimitOption")
	if err != nil {
		return err
	}
	*x = RateLimitOption(value)
	return nil
}

func (RateLimitOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}

// PluginType plugin type enum
type PluginType int32

const (
	JavaScript PluginType = 0
)

var PluginType_name = map[int32]string{
	0: "JavaScript",
}

var PluginType_value = map[string]int32{
	"JavaScript": 0,
}

func (x PluginType) Enum() *PluginType {
	p := new(PluginType)
	*p = x
	return p
}

func (x PluginType) String() string {
	return proto.EnumName(PluginType_name, int32(x))
}

func (x *PluginType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PluginType_value, data, "PluginType")
	if err != nil {
		return err
	}
	*x = PluginType(value)
	return nil
}

func (PluginType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{11}
}

// Proxy is a meta data of the gateway proxy
type Proxy struct {
	Addr                 string   `protobuf:"bytes,1,opt,name=addr" json:"addr"`
	AddrRPC              string   `protobuf:"bytes,2,opt,name=addrRPC" json:"addrRPC"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Proxy) Reset()         { *m = Proxy{} }
func (m *Proxy) String() string { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()    {}
func (*Proxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}
func (m *Proxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proxy.Merge(m, src)
}
func (m *Proxy) XXX_Size() int {
	return m.Size()
}
func (m *Proxy) XXX_DiscardUnknown() {
	xxx_messageInfo_Proxy.DiscardUnknown(m)
}

var xxx_messageInfo_Proxy proto.InternalMessageInfo

func (m *Proxy) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Proxy) GetAddrRPC() string {
	if m != nil {
		return m.AddrRPC
	}
	return ""
}

// Cluster is a set of server has same interface
type Cluster struct {
	ID                   uint64      `protobuf:"varint,1,opt,name=id" json:"id"`
	Name                 string      `protobuf:"bytes,2,opt,name=name" json:"name"`
	LoadBalance          LoadBalance `protobuf:"varint,3,opt,name=loadBalance,enum=metapb.LoadBalance" json:"loadBalance"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetLoadBalance() LoadBalance {
	if m != nil {
		return m.LoadBalance
	}
	return RoundRobin
}

// HeathCheck is the heath check
type HeathCheck struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path" json:"path"`
	Body                 string   `protobuf:"bytes,2,opt,name=body" json:"body"`
	CheckInterval        int64    `protobuf:"varint,3,opt,name=checkInterval" json:"checkInterval"`
	Timeout              int64    `protobuf:"varint,4,opt,name=timeout" json:"timeout"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeathCheck) Reset()         { *m = HeathCheck{} }
func (m *HeathCheck) String() string { return proto.CompactTextString(m) }
func (*HeathCheck) ProtoMessage()    {}
func (*HeathCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}
func (m *HeathCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeathCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeathCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeathCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeathCheck.Merge(m, src)
}
func (m *HeathCheck) XXX_Size() int {
	return m.Size()
}
func (m *HeathCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HeathCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HeathCheck proto.InternalMessageInfo

func (m *HeathCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HeathCheck) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *HeathCheck) GetCheckInterval() int64 {
	if m != nil {
		return m.CheckInterval
	}
	return 0
}

func (m *HeathCheck) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// CircuitBreaker circuit breaker
type CircuitBreaker struct {
	CloseTimeout         int64    `protobuf:"varint,1,opt,name=closeTimeout" json:"closeTimeout"`
	HalfTrafficRate      int32    `protobuf:"varint,2,opt,name=halfTrafficRate" json:"halfTrafficRate"`
	RateCheckPeriod      int64    `protobuf:"varint,3,opt,name=rateCheckPeriod" json:"rateCheckPeriod"`
	FailureRateToClose   int32    `protobuf:"varint,4,opt,name=failureRateToClose" json:"failureRateToClose"`
	SucceedRateToOpen    int32    `protobuf:"varint,5,opt,name=succeedRateToOpen" json:"succeedRateToOpen"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CircuitBreaker) Reset()         { *m = CircuitBreaker{} }
func (m *CircuitBreaker) String() string { return proto.CompactTextString(m) }
func (*CircuitBreaker) ProtoMessage()    {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}
func (m *CircuitBreaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CircuitBreaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CircuitBreaker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CircuitBreaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitBreaker.Merge(m, src)
}
func (m *CircuitBreaker) XXX_Size() int {
	return m.Size()
}
func (m *CircuitBreaker) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitBreaker.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitBreaker proto.InternalMessageInfo

func (m *CircuitBreaker) GetCloseTimeout() int64 {
	if m != nil {
		return m.CloseTimeout
	}
	return 0
}

func (m *CircuitBreaker) GetHalfTrafficRate() int32 {
	if m != nil {
		return m.HalfTrafficRate
	}
	return 0
}

func (m *CircuitBreaker) GetRateCheckPeriod() int64 {
	if m != nil {
		return m.RateCheckPeriod
	}
	return 0
}

func (m *CircuitBreaker) GetFailureRateToClose() int32 {
	if m != nil {
		return m.FailureRateToClose
	}
	return 0
}

func (m *CircuitBreaker) GetSucceedRateToOpen() int32 {
	if m != nil {
		return m.SucceedRateToOpen
	}
	return 0
}

// Server is a backend server that provide api
type Server struct {
	ID                   uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	Addr                 string          `protobuf:"bytes,2,opt,name=addr" json:"addr"`
	Protocol             Protocol        `protobuf:"varint,3,opt,name=protocol,enum=metapb.Protocol" json:"protocol"`
	MaxQPS               int64           `protobuf:"varint,4,opt,name=maxQPS" json:"maxQPS"`
	HeathCheck           *HeathCheck     `protobuf:"bytes,5,opt,name=heathCheck" json:"heathCheck,omitempty"`
	CircuitBreaker       *CircuitBreaker `protobuf:"bytes,6,opt,name=circuitBreaker" json:"circuitBreaker,omitempty"`
	Weight               int64           `protobuf:"varint,7,opt,name=weight" json:"weight"`
	RateLimitOption      RateLimitOption `protobuf:"varint,8,opt,name=rateLimitOption,enum=metapb.RateLimitOption" json:"rateLimitOption"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Server) Reset()         { *m = Server{} }
func (m *Server) String() string { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()    {}
func (*Server) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}
func (m *Server) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Server) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Server.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Server) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Server.Merge(m, src)
}
func (m *Server) XXX_Size() int {
	return m.Size()
}
func (m *Server) XXX_DiscardUnknown() {
	xxx_messageInfo_Server.DiscardUnknown(m)
}

var xxx_messageInfo_Server proto.InternalMessageInfo

func (m *Server) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Server) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Server) GetProtocol() Protocol {
	if m != nil {
		return m.Protocol
	}
	return HTTP
}

func (m *Server) GetMaxQPS() int64 {
	if m != nil {
		return m.MaxQPS
	}
	return 0
}

func (m *Server) GetHeathCheck() *HeathCheck {
	if m != nil {
		return m.HeathCheck
	}
	return nil
}

func (m *Server) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *Server) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Server) GetRateLimitOption() RateLimitOption {
	if m != nil {
		return m.RateLimitOption
	}
	return Wait
}

// Bind is a bind pair with cluster and server
type Bind struct {
	ClusterID            uint64   `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	ServerID             uint64   `protobuf:"varint,2,opt,name=serverID" json:"serverID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bind) Reset()         { *m = Bind{} }
func (m *Bind) String() string { return proto.CompactTextString(m) }
func (*Bind) ProtoMessage()    {}
func (*Bind) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}
func (m *Bind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bind.Merge(m, src)
}
func (m *Bind) XXX_Size() int {
	return m.Size()
}
func (m *Bind) XXX_DiscardUnknown() {
	xxx_messageInfo_Bind.DiscardUnknown(m)
}

var xxx_messageInfo_Bind proto.InternalMessageInfo

func (m *Bind) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Bind) GetServerID() uint64 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

// Pair is pair value
type PairValue struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value                string   `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PairValue) Reset()         { *m = PairValue{} }
func (m *PairValue) String() string { return proto.CompactTextString(m) }
func (*PairValue) ProtoMessage()    {}
func (*PairValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}
func (m *PairValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PairValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PairValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PairValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PairValue.Merge(m, src)
}
func (m *PairValue) XXX_Size() int {
	return m.Size()
}
func (m *PairValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PairValue.DiscardUnknown(m)
}

var xxx_messageInfo_PairValue proto.InternalMessageInfo

func (m *PairValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PairValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPAccessControl is for ip access control
type IPAccessControl struct {
	Whitelist            []string `protobuf:"bytes,1,rep,name=whitelist" json:"whitelist,omitempty"`
	Blacklist            []string `protobuf:"bytes,2,rep,name=blacklist" json:"blacklist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPAccessControl) Reset()         { *m = IPAccessControl{} }
func (m *IPAccessControl) String() string { return proto.CompactTextString(m) }
func (*IPAccessControl) ProtoMessage()    {}
func (*IPAccessControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}
func (m *IPAccessControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAccessControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAccessControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAccessControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAccessControl.Merge(m, src)
}
func (m *IPAccessControl) XXX_Size() int {
	return m.Size()
}
func (m *IPAccessControl) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAccessControl.DiscardUnknown(m)
}

var xxx_messageInfo_IPAccessControl proto.InternalMessageInfo

func (m *IPAccessControl) GetWhitelist() []string {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

func (m *IPAccessControl) GetBlacklist() []string {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// HTTPResult is a http result
type HTTPResult struct {
	Body                 []byte       `protobuf:"bytes,1,opt,name=body" json:"body,omitempty"`
	Headers              []*PairValue `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Cookies              []*PairValue `protobuf:"bytes,3,rep,name=cookies" json:"cookies,omitempty"`
	Code                 int32        `protobuf:"varint,4,opt,name=code" json:"code"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HTTPResult) Reset()         { *m = HTTPResult{} }
func (m *HTTPResult) String() string { return proto.CompactTextString(m) }
func (*HTTPResult) ProtoMessage()    {}
func (*HTTPResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}
func (m *HTTPResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPResult.Merge(m, src)
}
func (m *HTTPResult) XXX_Size() int {
	return m.Size()
}
func (m *HTTPResult) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPResult.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPResult proto.InternalMessageInfo

func (m *HTTPResult) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *HTTPResult) GetHeaders() []*PairValue {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HTTPResult) GetCookies() []*PairValue {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *HTTPResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// Parameter is a parameter from a http request
type Parameter struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	Source               Source   `protobuf:"varint,2,opt,name=source,enum=metapb.Source" json:"source"`
	Index                int32    `protobuf:"varint,3,opt,name=index" json:"index"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Parameter) Reset()         { *m = Parameter{} }
func (m *Parameter) String() string { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()    {}
func (*Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}
func (m *Parameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Parameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parameter.Merge(m, src)
}
func (m *Parameter) XXX_Size() int {
	return m.Size()
}
func (m *Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_Parameter proto.InternalMessageInfo

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetSource() Source {
	if m != nil {
		return m.Source
	}
	return QueryString
}

func (m *Parameter) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// ValidationRule is a validation rule
type ValidationRule struct {
	RuleType             RuleType `protobuf:"varint,1,opt,name=ruleType,enum=metapb.RuleType" json:"ruleType"`
	Expression           string   `protobuf:"bytes,2,opt,name=expression" json:"expression"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidationRule) Reset()         { *m = ValidationRule{} }
func (m *ValidationRule) String() string { return proto.CompactTextString(m) }
func (*ValidationRule) ProtoMessage()    {}
func (*ValidationRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}
func (m *ValidationRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidationRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidationRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidationRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidationRule.Merge(m, src)
}
func (m *ValidationRule) XXX_Size() int {
	return m.Size()
}
func (m *ValidationRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidationRule.DiscardUnknown(m)
}

var xxx_messageInfo_ValidationRule proto.InternalMessageInfo

func (m *ValidationRule) GetRuleType() RuleType {
	if m != nil {
		return m.RuleType
	}
	return RuleRegexp
}

func (m *ValidationRule) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

// Validation is a validation
type Validation struct {
	Parameter            Parameter        `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Required             bool             `protobuf:"varint,2,opt,name=required" json:"required"`
	Rules                []ValidationRule `protobuf:"bytes,3,rep,name=rules" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Validation) Reset()         { *m = Validation{} }
func (m *Validation) String() string { return proto.CompactTextString(m) }
func (*Validation) ProtoMessage()    {}
func (*Validation) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{11}
}
func (m *Validation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validation.Merge(m, src)
}
func (m *Validation) XXX_Size() int {
	return m.Size()
}
func (m *Validation) XXX_DiscardUnknown() {
	xxx_messageInfo_Validation.DiscardUnknown(m)
}

var xxx_messageInfo_Validation proto.InternalMessageInfo

func (m *Validation) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Validation) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *Validation) GetRules() []ValidationRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// RetryStrategy retry strategy
type RetryStrategy struct {
	Interval             int32    `protobuf:"varint,1,opt,name=interval" json:"interval"`
	MaxTimes             int32    `protobuf:"varint,2,opt,name=maxTimes" json:"maxTimes"`
	Codes                []int32  `protobuf:"varint,3,rep,name=codes" json:"codes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetryStrategy) Reset()         { *m = RetryStrategy{} }
func (m *RetryStrategy) String() string { return proto.CompactTextString(m) }
func (*RetryStrategy) ProtoMessage()    {}
func (*RetryStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{12}
}
func (m *RetryStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryStrategy.Merge(m, src)
}
func (m *RetryStrategy) XXX_Size() int {
	return m.Size()
}
func (m *RetryStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryStrategy proto.InternalMessageInfo

func (m *RetryStrategy) GetInterval() int32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *RetryStrategy) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

func (m *RetryStrategy) GetCodes() []int32 {
	if m != nil {
		return m.Codes
	}
	return nil
}

// DispatchNode is the request forward to
type DispatchNode struct {
	ClusterID            uint64         `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	URLRewrite           string         `protobuf:"bytes,2,opt,name=urlRewrite" json:"urlRewrite"`
	AttrName             string         `protobuf:"bytes,3,opt,name=attrName" json:"attrName"`
	Validations          []*Validation  `protobuf:"bytes,4,rep,name=validations" json:"validations,omitempty"`
	Cache                *Cache         `protobuf:"bytes,5,opt,name=cache" json:"cache,omitempty"`
	DefaultValue         *HTTPResult    `protobuf:"bytes,6,opt,name=defaultValue" json:"defaultValue,omitempty"`
	UseDefault           bool           `protobuf:"varint,7,opt,name=useDefault" json:"useDefault"`
	BatchIndex           int32          `protobuf:"varint,8,opt,name=batchIndex" json:"batchIndex"`
	RetryStrategy        *RetryStrategy `protobuf:"bytes,9,opt,name=retryStrategy" json:"retryStrategy,omitempty"`
	WriteTimeout         int64          `protobuf:"varint,10,opt,name=writeTimeout" json:"writeTimeout"`
	ReadTimeout          int64          `protobuf:"varint,11,opt,name=readTimeout" json:"readTimeout"`
	HostType             HostType       `protobuf:"varint,12,opt,name=hostType,enum=metapb.HostType" json:"hostType"`
	CustemHost           string         `protobuf:"bytes,13,opt,name=custemHost" json:"custemHost"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DispatchNode) Reset()         { *m = DispatchNode{} }
func (m *DispatchNode) String() string { return proto.CompactTextString(m) }
func (*DispatchNode) ProtoMessage()    {}
func (*DispatchNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{13}
}
func (m *DispatchNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchNode.Merge(m, src)
}
func (m *DispatchNode) XXX_Size() int {
	return m.Size()
}
func (m *DispatchNode) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchNode.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchNode proto.InternalMessageInfo

func (m *DispatchNode) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *DispatchNode) GetURLRewrite() string {
	if m != nil {
		return m.URLRewrite
	}
	return ""
}

func (m *DispatchNode) GetAttrName() string {
	if m != nil {
		return m.AttrName
	}
	return ""
}

func (m *DispatchNode) GetValidations() []*Validation {
	if m != nil {
		return m.Validations
	}
	return nil
}

func (m *DispatchNode) GetCache() *Cache {
	if m != nil {
		return m.Cache
	}
	return nil
}

func (m *DispatchNode) GetDefaultValue() *HTTPResult {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *DispatchNode) GetUseDefault() bool {
	if m != nil {
		return m.UseDefault
	}
	return false
}

func (m *DispatchNode) GetBatchIndex() int32 {
	if m != nil {
		return m.BatchIndex
	}
	return 0
}

func (m *DispatchNode) GetRetryStrategy() *RetryStrategy {
	if m != nil {
		return m.RetryStrategy
	}
	return nil
}

func (m *DispatchNode) GetWriteTimeout() int64 {
	if m != nil {
		return m.WriteTimeout
	}
	return 0
}

func (m *DispatchNode) GetReadTimeout() int64 {
	if m != nil {
		return m.ReadTimeout
	}
	return 0
}

func (m *DispatchNode) GetHostType() HostType {
	if m != nil {
		return m.HostType
	}
	return HostOrigin
}

func (m *DispatchNode) GetCustemHost() string {
	if m != nil {
		return m.CustemHost
	}
	return ""
}

// Cache is used for cache api result
type Cache struct {
	Keys                 []Parameter `protobuf:"bytes,1,rep,name=keys" json:"keys"`
	Deadline             uint64      `protobuf:"varint,2,opt,name=deadline" json:"deadline"`
	Conditions           []Condition `protobuf:"bytes,3,rep,name=conditions" json:"conditions"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Cache) Reset()         { *m = Cache{} }
func (m *Cache) String() string { return proto.CompactTextString(m) }
func (*Cache) ProtoMessage()    {}
func (*Cache) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{14}
}
func (m *Cache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cache.Merge(m, src)
}
func (m *Cache) XXX_Size() int {
	return m.Size()
}
func (m *Cache) XXX_DiscardUnknown() {
	xxx_messageInfo_Cache.DiscardUnknown(m)
}

var xxx_messageInfo_Cache proto.InternalMessageInfo

func (m *Cache) GetKeys() []Parameter {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Cache) GetDeadline() uint64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

func (m *Cache) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// RenderTemplate the template that render to client
type RenderTemplate struct {
	Objects              []*RenderObject `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RenderTemplate) Reset()         { *m = RenderTemplate{} }
func (m *RenderTemplate) String() string { return proto.CompactTextString(m) }
func (*RenderTemplate) ProtoMessage()    {}
func (*RenderTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{15}
}
func (m *RenderTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenderTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenderTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenderTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenderTemplate.Merge(m, src)
}
func (m *RenderTemplate) XXX_Size() int {
	return m.Size()
}
func (m *RenderTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_RenderTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_RenderTemplate proto.InternalMessageInfo

func (m *RenderTemplate) GetObjects() []*RenderObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

// RenderObject the object in the render template
type RenderObject struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name" json:"name"`
	Attrs                []*RenderAttr `protobuf:"bytes,2,rep,name=attrs" json:"attrs,omitempty"`
	FlatAttrs            bool          `protobuf:"varint,3,opt,name=flatAttrs" json:"flatAttrs"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RenderObject) Reset()         { *m = RenderObject{} }
func (m *RenderObject) String() string { return proto.CompactTextString(m) }
func (*RenderObject) ProtoMessage()    {}
func (*RenderObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{16}
}
func (m *RenderObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenderObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenderObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenderObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenderObject.Merge(m, src)
}
func (m *RenderObject) XXX_Size() int {
	return m.Size()
}
func (m *RenderObject) XXX_DiscardUnknown() {
	xxx_messageInfo_RenderObject.DiscardUnknown(m)
}

var xxx_messageInfo_RenderObject proto.InternalMessageInfo

func (m *RenderObject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RenderObject) GetAttrs() []*RenderAttr {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *RenderObject) GetFlatAttrs() bool {
	if m != nil {
		return m.FlatAttrs
	}
	return false
}

// RenderAttr the attr in the render object
type RenderAttr struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	ExtractExp           string   `protobuf:"bytes,2,opt,name=extractExp" json:"extractExp"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenderAttr) Reset()         { *m = RenderAttr{} }
func (m *RenderAttr) String() string { return proto.CompactTextString(m) }
func (*RenderAttr) ProtoMessage()    {}
func (*RenderAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{17}
}
func (m *RenderAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenderAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenderAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenderAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenderAttr.Merge(m, src)
}
func (m *RenderAttr) XXX_Size() int {
	return m.Size()
}
func (m *RenderAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_RenderAttr.DiscardUnknown(m)
}

var xxx_messageInfo_RenderAttr proto.InternalMessageInfo

func (m *RenderAttr) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RenderAttr) GetExtractExp() string {
	if m != nil {
		return m.ExtractExp
	}
	return ""
}

// API is the api for dispatcher
type API struct {
	ID                   uint64            `protobuf:"varint,1,opt,name=id" json:"id"`
	Name                 string            `protobuf:"bytes,2,opt,name=name" json:"name"`
	URLPattern           string            `protobuf:"bytes,3,opt,name=urlPattern" json:"urlPattern"`
	Method               string            `protobuf:"bytes,4,opt,name=method" json:"method"`
	Domain               string            `protobuf:"bytes,5,opt,name=domain" json:"domain"`
	Status               Status            `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	IPAccessControl      *IPAccessControl  `protobuf:"bytes,7,opt,name=ipAccessControl" json:"ipAccessControl,omitempty"`
	DefaultValue         *HTTPResult       `protobuf:"bytes,8,opt,name=defaultValue" json:"defaultValue,omitempty"`
	Nodes                []*DispatchNode   `protobuf:"bytes,9,rep,name=nodes" json:"nodes,omitempty"`
	Perms                []string          `protobuf:"bytes,10,rep,name=perms" json:"perms,omitempty"`
	AuthFilter           string            `protobuf:"bytes,11,opt,name=authFilter" json:"authFilter"`
	RenderTemplate       *RenderTemplate   `protobuf:"bytes,12,opt,name=renderTemplate" json:"renderTemplate,omitempty"`
	UseDefault           bool              `protobuf:"varint,13,opt,name=useDefault" json:"useDefault"`
	MatchRule            MatchRule         `protobuf:"varint,14,opt,name=matchRule,enum=metapb.MatchRule" json:"matchRule"`
	Position             uint32            `protobuf:"varint,15,opt,name=position" json:"position"`
	Tags                 []*PairValue      `protobuf:"bytes,16,rep,name=tags" json:"tags,omitempty"`
	WebSocketOptions     *WebSocketOptions `protobuf:"bytes,17,opt,name=webSocketOptions" json:"webSocketOptions,omitempty"`
	MaxQPS               int64             `protobuf:"varint,18,opt,name=maxQPS" json:"maxQPS"`
	CircuitBreaker       *CircuitBreaker   `protobuf:"bytes,19,opt,name=circuitBreaker" json:"circuitBreaker,omitempty"`
	RateLimitOption      RateLimitOption   `protobuf:"varint,20,opt,name=rateLimitOption,enum=metapb.RateLimitOption" json:"rateLimitOption"`
	UseTLS               bool              `protobuf:"varint,21,opt,name=useTLS" json:"useTLS"`
	TlsEmbedCert         *TLSEmbedCert     `protobuf:"bytes,22,opt,name=tlsEmbedCert" json:"tlsEmbedCert,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *API) Reset()         { *m = API{} }
func (m *API) String() string { return proto.CompactTextString(m) }
func (*API) ProtoMessage()    {}
func (*API) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{18}
}
func (m *API) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *API) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_API.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *API) XXX_Merge(src proto.Message) {
	xxx_messageInfo_API.Merge(m, src)
}
func (m *API) XXX_Size() int {
	return m.Size()
}
func (m *API) XXX_DiscardUnknown() {
	xxx_messageInfo_API.DiscardUnknown(m)
}

var xxx_messageInfo_API proto.InternalMessageInfo

func (m *API) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *API) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *API) GetURLPattern() string {
	if m != nil {
		return m.URLPattern
	}
	return ""
}

func (m *API) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *API) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *API) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *API) GetIPAccessControl() *IPAccessControl {
	if m != nil {
		return m.IPAccessControl
	}
	return nil
}

func (m *API) GetDefaultValue() *HTTPResult {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *API) GetNodes() []*DispatchNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *API) GetPerms() []string {
	if m != nil {
		return m.Perms
	}
	return nil
}

func (m *API) GetAuthFilter() string {
	if m != nil {
		return m.AuthFilter
	}
	return ""
}

func (m *API) GetRenderTemplate() *RenderTemplate {
	if m != nil {
		return m.RenderTemplate
	}
	return nil
}

func (m *API) GetUseDefault() bool {
	if m != nil {
		return m.UseDefault
	}
	return false
}

func (m *API) GetMatchRule() MatchRule {
	if m != nil {
		return m.MatchRule
	}
	return MatchDefault
}

func (m *API) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *API) GetTags() []*PairValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *API) GetWebSocketOptions() *WebSocketOptions {
	if m != nil {
		return m.WebSocketOptions
	}
	return nil
}

func (m *API) GetMaxQPS() int64 {
	if m != nil {
		return m.MaxQPS
	}
	return 0
}

func (m *API) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *API) GetRateLimitOption() RateLimitOption {
	if m != nil {
		return m.RateLimitOption
	}
	return Wait
}

func (m *API) GetUseTLS() bool {
	if m != nil {
		return m.UseTLS
	}
	return false
}

func (m *API) GetTlsEmbedCert() *TLSEmbedCert {
	if m != nil {
		return m.TlsEmbedCert
	}
	return nil
}

// TLSEmbedCert tlsEmbedCert options
type TLSEmbedCert struct {
	CertData             []byte   `protobuf:"bytes,1,opt,name=certData" json:"certData,omitempty"`
	KeyData              []byte   `protobuf:"bytes,2,opt,name=keyData" json:"keyData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLSEmbedCert) Reset()         { *m = TLSEmbedCert{} }
func (m *TLSEmbedCert) String() string { return proto.CompactTextString(m) }
func (*TLSEmbedCert) ProtoMessage()    {}
func (*TLSEmbedCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{19}
}
func (m *TLSEmbedCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSEmbedCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSEmbedCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSEmbedCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSEmbedCert.Merge(m, src)
}
func (m *TLSEmbedCert) XXX_Size() int {
	return m.Size()
}
func (m *TLSEmbedCert) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSEmbedCert.DiscardUnknown(m)
}

var xxx_messageInfo_TLSEmbedCert proto.InternalMessageInfo

func (m *TLSEmbedCert) GetCertData() []byte {
	if m != nil {
		return m.CertData
	}
	return nil
}

func (m *TLSEmbedCert) GetKeyData() []byte {
	if m != nil {
		return m.KeyData
	}
	return nil
}

// Condition is a condition for routing
type Condition struct {
	Parameter            Parameter `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Cmp                  CMP       `protobuf:"varint,2,opt,name=cmp,enum=metapb.CMP" json:"cmp"`
	Expect               string    `protobuf:"bytes,3,opt,name=expect" json:"expect"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{20}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Condition) GetCmp() CMP {
	if m != nil {
		return m.Cmp
	}
	return CMPEQ
}

func (m *Condition) GetExpect() string {
	if m != nil {
		return m.Expect
	}
	return ""
}

// Routing is a routing
type Routing struct {
	ID                   uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	ClusterID            uint64          `protobuf:"varint,2,opt,name=clusterID" json:"clusterID"`
	Conditions           []Condition     `protobuf:"bytes,3,rep,name=conditions" json:"conditions"`
	Strategy             RoutingStrategy `protobuf:"varint,4,opt,name=strategy,enum=metapb.RoutingStrategy" json:"strategy"`
	TrafficRate          int32           `protobuf:"varint,5,opt,name=trafficRate" json:"trafficRate"`
	Status               Status          `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	API                  uint64          `protobuf:"varint,7,opt,name=api" json:"api"`
	Name                 string          `protobuf:"bytes,8,opt,name=name" json:"name"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Routing) Reset()         { *m = Routing{} }
func (m *Routing) String() string { return proto.CompactTextString(m) }
func (*Routing) ProtoMessage()    {}
func (*Routing) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{21}
}
func (m *Routing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Routing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Routing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Routing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Routing.Merge(m, src)
}
func (m *Routing) XXX_Size() int {
	return m.Size()
}
func (m *Routing) XXX_DiscardUnknown() {
	xxx_messageInfo_Routing.DiscardUnknown(m)
}

var xxx_messageInfo_Routing proto.InternalMessageInfo

func (m *Routing) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Routing) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Routing) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Routing) GetStrategy() RoutingStrategy {
	if m != nil {
		return m.Strategy
	}
	return Copy
}

func (m *Routing) GetTrafficRate() int32 {
	if m != nil {
		return m.TrafficRate
	}
	return 0
}

func (m *Routing) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *Routing) GetAPI() uint64 {
	if m != nil {
		return m.API
	}
	return 0
}

func (m *Routing) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// WebSocketOptions websocket options
type WebSocketOptions struct {
	Origin               string   `protobuf:"bytes,1,opt,name=origin" json:"origin"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSocketOptions) Reset()         { *m = WebSocketOptions{} }
func (m *WebSocketOptions) String() string { return proto.CompactTextString(m) }
func (*WebSocketOptions) ProtoMessage()    {}
func (*WebSocketOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{22}
}
func (m *WebSocketOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSocketOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSocketOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebSocketOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSocketOptions.Merge(m, src)
}
func (m *WebSocketOptions) XXX_Size() int {
	return m.Size()
}
func (m *WebSocketOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSocketOptions.DiscardUnknown(m)
}

var xxx_messageInfo_WebSocketOptions proto.InternalMessageInfo

func (m *WebSocketOptions) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

// System system
type System struct {
	Count                CountMetric `protobuf:"bytes,1,opt,name=count" json:"count"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *System) Reset()         { *m = System{} }
func (m *System) String() string { return proto.CompactTextString(m) }
func (*System) ProtoMessage()    {}
func (*System) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{23}
}
func (m *System) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *System) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_System.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *System) XXX_Merge(src proto.Message) {
	xxx_messageInfo_System.Merge(m, src)
}
func (m *System) XXX_Size() int {
	return m.Size()
}
func (m *System) XXX_DiscardUnknown() {
	xxx_messageInfo_System.DiscardUnknown(m)
}

var xxx_messageInfo_System proto.InternalMessageInfo

func (m *System) GetCount() CountMetric {
	if m != nil {
		return m.Count
	}
	return CountMetric{}
}

// CountMetric count metric
type CountMetric struct {
	Cluster              int64    `protobuf:"varint,1,opt,name=cluster" json:"cluster"`
	Server               int64    `protobuf:"varint,2,opt,name=server" json:"server"`
	API                  int64    `protobuf:"varint,3,opt,name=api" json:"api"`
	Routing              int64    `protobuf:"varint,4,opt,name=routing" json:"routing"`
	Plugin               int64    `protobuf:"varint,5,opt,name=plugin" json:"plugin"`
	AppliedPlugin        int64    `protobuf:"varint,6,opt,name=appliedPlugin" json:"appliedPlugin"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CountMetric) Reset()         { *m = CountMetric{} }
func (m *CountMetric) String() string { return proto.CompactTextString(m) }
func (*CountMetric) ProtoMessage()    {}
func (*CountMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{24}
}
func (m *CountMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountMetric.Merge(m, src)
}
func (m *CountMetric) XXX_Size() int {
	return m.Size()
}
func (m *CountMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_CountMetric.DiscardUnknown(m)
}

var xxx_messageInfo_CountMetric proto.InternalMessageInfo

func (m *CountMetric) GetCluster() int64 {
	if m != nil {
		return m.Cluster
	}
	return 0
}

func (m *CountMetric) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *CountMetric) GetAPI() int64 {
	if m != nil {
		return m.API
	}
	return 0
}

func (m *CountMetric) GetRouting() int64 {
	if m != nil {
		return m.Routing
	}
	return 0
}

func (m *CountMetric) GetPlugin() int64 {
	if m != nil {
		return m.Plugin
	}
	return 0
}

func (m *CountMetric) GetAppliedPlugin() int64 {
	if m != nil {
		return m.AppliedPlugin
	}
	return 0
}

// Plugin plugin
type Plugin struct {
	ID                   uint64     `protobuf:"varint,1,opt,name=id" json:"id"`
	Name                 string     `protobuf:"bytes,2,opt,name=name" json:"name"`
	Author               string     `protobuf:"bytes,3,opt,name=author" json:"author"`
	Email                string     `protobuf:"bytes,4,opt,name=email" json:"email"`
	Status               Status     `protobuf:"varint,5,opt,name=status,enum=metapb.Status" json:"status"`
	UpdateAt             int64      `protobuf:"varint,6,opt,name=updateAt" json:"updateAt"`
	Version              int64      `protobuf:"varint,7,opt,name=version" json:"version"`
	Type                 PluginType `protobuf:"varint,8,opt,name=type,enum=metapb.PluginType" json:"type"`
	Content              []byte     `protobuf:"bytes,9,opt,name=content" json:"content,omitempty"`
	Cfg                  []byte     `protobuf:"bytes,10,opt,name=cfg" json:"cfg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Plugin) Reset()         { *m = Plugin{} }
func (m *Plugin) String() string { return proto.CompactTextString(m) }
func (*Plugin) ProtoMessage()    {}
func (*Plugin) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{25}
}
func (m *Plugin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plugin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plugin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plugin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plugin.Merge(m, src)
}
func (m *Plugin) XXX_Size() int {
	return m.Size()
}
func (m *Plugin) XXX_DiscardUnknown() {
	xxx_messageInfo_Plugin.DiscardUnknown(m)
}

var xxx_messageInfo_Plugin proto.InternalMessageInfo

func (m *Plugin) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Plugin) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Plugin) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Plugin) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Plugin) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *Plugin) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func (m *Plugin) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Plugin) GetType() PluginType {
	if m != nil {
		return m.Type
	}
	return JavaScript
}

func (m *Plugin) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Plugin) GetCfg() []byte {
	if m != nil {
		return m.Cfg
	}
	return nil
}

// AppliedPlugins applied plugins
type AppliedPlugins struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id" json:"id"`
	AppliedIDs           []uint64 `protobuf:"varint,2,rep,name=appliedIDs" json:"appliedIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppliedPlugins) Reset()         { *m = AppliedPlugins{} }
func (m *AppliedPlugins) String() string { return proto.CompactTextString(m) }
func (*AppliedPlugins) ProtoMessage()    {}
func (*AppliedPlugins) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{26}
}
func (m *AppliedPlugins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppliedPlugins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppliedPlugins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppliedPlugins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppliedPlugins.Merge(m, src)
}
func (m *AppliedPlugins) XXX_Size() int {
	return m.Size()
}
func (m *AppliedPlugins) XXX_DiscardUnknown() {
	xxx_messageInfo_AppliedPlugins.DiscardUnknown(m)
}

var xxx_messageInfo_AppliedPlugins proto.InternalMessageInfo

func (m *AppliedPlugins) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *AppliedPlugins) GetAppliedIDs() []uint64 {
	if m != nil {
		return m.AppliedIDs
	}
	return nil
}

func init() {
	proto.RegisterEnum("metapb.Status", Status_name, Status_value)
	proto.RegisterEnum("metapb.CircuitStatus", CircuitStatus_name, CircuitStatus_value)
	proto.RegisterEnum("metapb.LoadBalance", LoadBalance_name, LoadBalance_value)
	proto.RegisterEnum("metapb.Protocol", Protocol_name, Protocol_value)
	proto.RegisterEnum("metapb.Source", Source_name, Source_value)
	proto.RegisterEnum("metapb.RuleType", RuleType_name, RuleType_value)
	proto.RegisterEnum("metapb.CMP", CMP_name, CMP_value)
	proto.RegisterEnum("metapb.RoutingStrategy", RoutingStrategy_name, RoutingStrategy_value)
	proto.RegisterEnum("metapb.MatchRule", MatchRule_name, MatchRule_value)
	proto.RegisterEnum("metapb.HostType", HostType_name, HostType_value)
	proto.RegisterEnum("metapb.RateLimitOption", RateLimitOption_name, RateLimitOption_value)
	proto.RegisterEnum("metapb.PluginType", PluginType_name, PluginType_value)
	proto.RegisterType((*Proxy)(nil), "metapb.Proxy")
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*HeathCheck)(nil), "metapb.HeathCheck")
	proto.RegisterType((*CircuitBreaker)(nil), "metapb.CircuitBreaker")
	proto.RegisterType((*Server)(nil), "metapb.Server")
	proto.RegisterType((*Bind)(nil), "metapb.Bind")
	proto.RegisterType((*PairValue)(nil), "metapb.PairValue")
	proto.RegisterType((*IPAccessControl)(nil), "metapb.IPAccessControl")
	proto.RegisterType((*HTTPResult)(nil), "metapb.HTTPResult")
	proto.RegisterType((*Parameter)(nil), "metapb.Parameter")
	proto.RegisterType((*ValidationRule)(nil), "metapb.ValidationRule")
	proto.RegisterType((*Validation)(nil), "metapb.Validation")
	proto.RegisterType((*RetryStrategy)(nil), "metapb.RetryStrategy")
	proto.RegisterType((*DispatchNode)(nil), "metapb.DispatchNode")
	proto.RegisterType((*Cache)(nil), "metapb.Cache")
	proto.RegisterType((*RenderTemplate)(nil), "metapb.RenderTemplate")
	proto.RegisterType((*RenderObject)(nil), "metapb.RenderObject")
	proto.RegisterType((*RenderAttr)(nil), "metapb.RenderAttr")
	proto.RegisterType((*API)(nil), "metapb.API")
	proto.RegisterType((*TLSEmbedCert)(nil), "metapb.TLSEmbedCert")
	proto.RegisterType((*Condition)(nil), "metapb.Condition")
	proto.RegisterType((*Routing)(nil), "metapb.Routing")
	proto.RegisterType((*WebSocketOptions)(nil), "metapb.WebSocketOptions")
	proto.RegisterType((*System)(nil), "metapb.System")
	proto.RegisterType((*CountMetric)(nil), "metapb.CountMetric")
	proto.RegisterType((*Plugin)(nil), "metapb.Plugin")
	proto.RegisterType((*AppliedPlugins)(nil), "metapb.AppliedPlugins")
}

func init() { proto.RegisterFile("metapb.proto", fileDescriptor_77b4d575d5a68dda) }

var fileDescriptor_77b4d575d5a68dda = []byte{
	// 2249 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0xf5, 0xcf, 0xd2, 0x93, 0x6c, 0x33, 0xb3, 0xc9, 0x2e, 0x11, 0xa4, 0x4e, 0xc0, 0x6d,
	0xb3, 0x86, 0x76, 0x91, 0x2d, 0x8c, 0x5d, 0xb4, 0xe9, 0x16, 0x45, 0x65, 0x39, 0x9b, 0x78, 0x61,
	0xc7, 0x0a, 0xa5, 0x6c, 0x80, 0xa2, 0x97, 0x31, 0x39, 0x96, 0xb8, 0xa6, 0x48, 0x76, 0x38, 0x74,
	0x2c, 0xa0, 0xc7, 0xb6, 0xa7, 0x02, 0xbd, 0xf4, 0xd0, 0x7e, 0x9d, 0x9e, 0xf6, 0xd0, 0xc3, 0x1e,
	0x8a, 0x1e, 0x83, 0x36, 0x3d, 0xf6, 0x4b, 0x14, 0x6f, 0x86, 0x43, 0x0d, 0x65, 0x27, 0xdd, 0xf8,
	0x24, 0xf1, 0xf7, 0x7e, 0xc3, 0x79, 0xf3, 0xfe, 0x0f, 0xa1, 0x37, 0x67, 0x82, 0xa6, 0x27, 0x0f,
	0x52, 0x9e, 0x88, 0x84, 0xb4, 0xd4, 0xd3, 0xed, 0x9b, 0xd3, 0x64, 0x9a, 0x48, 0xe8, 0x53, 0xfc,
	0xa7, 0xa4, 0xee, 0x00, 0x9a, 0x23, 0x9e, 0x5c, 0x2c, 0x88, 0x03, 0x0d, 0x1a, 0x04, 0xdc, 0xb1,
	0xee, 0x59, 0x3b, 0x9d, 0xbd, 0xc6, 0xb7, 0xaf, 0xee, 0xae, 0x79, 0x12, 0x21, 0xdb, 0xb0, 0x8e,
	0xbf, 0xde, 0x68, 0xe8, 0xd4, 0x0c, 0xa1, 0x06, 0xdd, 0xdf, 0xc2, 0xfa, 0x30, 0xca, 0x33, 0xc1,
	0x38, 0xb9, 0x0d, 0xb5, 0x30, 0x90, 0xaf, 0x68, 0xec, 0x01, 0xb2, 0x5e, 0xbf, 0xba, 0x5b, 0x3b,
	0xd8, 0xf7, 0x6a, 0x61, 0x80, 0x1b, 0xc4, 0x74, 0xce, 0x2a, 0xef, 0x90, 0x08, 0xf9, 0x02, 0xba,
	0x51, 0x42, 0x83, 0x3d, 0x1a, 0xd1, 0xd8, 0x67, 0x4e, 0xfd, 0x9e, 0xb5, 0xb3, 0xb9, 0xfb, 0xde,
	0x83, 0xe2, 0x14, 0x87, 0x4b, 0x51, 0xb1, 0xca, 0x64, 0xbb, 0x7f, 0xb4, 0x00, 0x9e, 0x30, 0x2a,
	0x66, 0xc3, 0x19, 0xf3, 0xcf, 0x70, 0x97, 0x94, 0x8a, 0x59, 0xf5, 0x18, 0x88, 0xa0, 0xe4, 0x24,
	0x09, 0x16, 0xd5, 0xfd, 0x11, 0x21, 0x7d, 0xd8, 0xf0, 0x71, 0xf1, 0x41, 0x2c, 0x18, 0x3f, 0xa7,
	0x91, 0xd4, 0xa0, 0x5e, 0x50, 0xaa, 0x22, 0x34, 0x86, 0x08, 0xe7, 0x2c, 0xc9, 0x85, 0xd3, 0x30,
	0x58, 0x1a, 0x74, 0x7f, 0x57, 0x83, 0xcd, 0x61, 0xc8, 0xfd, 0x3c, 0x14, 0x7b, 0x9c, 0xd1, 0x33,
	0xc6, 0xc9, 0x0e, 0xf4, 0xfc, 0x28, 0xc9, 0xd8, 0xa4, 0x58, 0x67, 0x19, 0xeb, 0x2a, 0x12, 0xf2,
	0x00, 0xb6, 0x66, 0x34, 0x3a, 0x9d, 0x70, 0x7a, 0x7a, 0x1a, 0xfa, 0x1e, 0x15, 0xca, 0x5a, 0xcd,
	0x82, 0xbc, 0x2a, 0x44, 0x3e, 0xa7, 0x82, 0xc9, 0x93, 0x8f, 0x18, 0x0f, 0x93, 0xa0, 0xa2, 0xfa,
	0xaa, 0x90, 0x7c, 0x06, 0xe4, 0x94, 0x86, 0x51, 0xce, 0x19, 0x2e, 0x9f, 0x24, 0x43, 0xdc, 0x5c,
	0x9e, 0x43, 0x6f, 0x71, 0x85, 0x9c, 0xec, 0xc2, 0x8d, 0x2c, 0xf7, 0x7d, 0xc6, 0x02, 0x85, 0x1e,
	0xa7, 0x2c, 0x76, 0x9a, 0xc6, 0xa2, 0xcb, 0x62, 0xf7, 0xbf, 0x35, 0x68, 0x8d, 0x19, 0x3f, 0xff,
	0xff, 0x31, 0x21, 0x83, 0xae, 0x76, 0x29, 0xe8, 0x76, 0xa1, 0x2d, 0x03, 0xd4, 0x4f, 0xa2, 0x22,
	0x20, 0x6c, 0x1d, 0x10, 0xa3, 0x02, 0x2f, 0xf8, 0x25, 0x8f, 0xdc, 0x81, 0xd6, 0x9c, 0x5e, 0x3c,
	0x1b, 0x8d, 0x2b, 0xae, 0x29, 0x30, 0xb2, 0x0b, 0x30, 0x2b, 0xe3, 0x44, 0xea, 0xdf, 0xdd, 0x25,
	0xfa, 0x9d, 0xcb, 0x08, 0xf2, 0x0c, 0x16, 0xf9, 0x05, 0x6c, 0xfa, 0x15, 0x67, 0x3a, 0x2d, 0xb9,
	0xee, 0x7d, 0xbd, 0xae, 0xea, 0x6a, 0x6f, 0x85, 0x8d, 0x1a, 0xbd, 0x64, 0xe1, 0x74, 0x26, 0x9c,
	0x75, 0x53, 0x23, 0x85, 0x91, 0xc7, 0xca, 0x7d, 0x87, 0xe1, 0x3c, 0x14, 0xc7, 0xa9, 0x08, 0x93,
	0xd8, 0x69, 0xcb, 0xa3, 0x7e, 0xa0, 0x5f, 0xef, 0x55, 0xc5, 0xa6, 0x5f, 0x0d, 0xd8, 0x3d, 0x84,
	0xc6, 0x5e, 0x18, 0x07, 0xc4, 0x85, 0x8e, 0xaf, 0x32, 0xf1, 0x60, 0xbf, 0xb0, 0xb8, 0x5a, 0xb1,
	0x84, 0xc9, 0x3d, 0x68, 0x67, 0xd2, 0x31, 0x07, 0xfb, 0xd2, 0xec, 0x9a, 0x52, 0xa2, 0xee, 0x00,
	0x3a, 0x23, 0x1a, 0xf2, 0xaf, 0x69, 0x94, 0xb3, 0x32, 0x6b, 0xad, 0x4b, 0x59, 0x7b, 0x1b, 0x9a,
	0xe7, 0x48, 0xa9, 0x38, 0x4f, 0x41, 0xee, 0x11, 0x6c, 0x1d, 0x8c, 0x06, 0xbe, 0xcf, 0xb2, 0x6c,
	0x98, 0xc4, 0x82, 0x4b, 0xe7, 0x74, 0x5e, 0xce, 0x42, 0xc1, 0xa2, 0x30, 0xc3, 0x14, 0xa8, 0xef,
	0x74, 0xbc, 0x25, 0x80, 0xd2, 0x93, 0x88, 0xfa, 0x67, 0x52, 0x5a, 0x53, 0xd2, 0x12, 0x70, 0xff,
	0x8c, 0x39, 0x3e, 0x99, 0x8c, 0x3c, 0x96, 0xe5, 0x91, 0x20, 0xa4, 0xc8, 0x64, 0xd4, 0xa9, 0x57,
	0xe4, 0xf0, 0xc7, 0xb0, 0x3e, 0x63, 0x34, 0x60, 0x3c, 0x93, 0xcb, 0xbb, 0xbb, 0x37, 0xca, 0x70,
	0xd1, 0x67, 0xf1, 0x34, 0x03, 0xc9, 0x7e, 0x92, 0x9c, 0x85, 0x2c, 0x73, 0xea, 0x6f, 0x24, 0x17,
	0x0c, 0xb4, 0x80, 0x9f, 0x04, 0xd5, 0x34, 0x91, 0x88, 0x9b, 0xa0, 0xa1, 0x38, 0x9d, 0x33, 0x2c,
	0x7d, 0x6f, 0x36, 0xd4, 0x27, 0xd0, 0xca, 0x92, 0x9c, 0xfb, 0xca, 0x52, 0x9b, 0xbb, 0x9b, 0x7a,
	0xb3, 0xb1, 0x44, 0x75, 0x50, 0x28, 0x0e, 0x9a, 0x35, 0x8c, 0x03, 0x76, 0x21, 0xa3, 0x5e, 0xef,
	0xa7, 0x20, 0xf7, 0x1b, 0xd8, 0xfc, 0x9a, 0x46, 0x61, 0x40, 0xd1, 0xeb, 0x5e, 0x1e, 0x61, 0x6e,
	0xb6, 0x79, 0x1e, 0xb1, 0xc9, 0x22, 0x55, 0x3b, 0x1b, 0x69, 0xe2, 0x15, 0xb8, 0xf6, 0xaf, 0xe6,
	0x91, 0x1f, 0x02, 0xb0, 0x8b, 0x94, 0xb3, 0x2c, 0xc3, 0x88, 0x33, 0xbd, 0x67, 0xe0, 0xee, 0x5f,
	0x2d, 0x80, 0xe5, 0x66, 0xe4, 0x73, 0xe8, 0xa4, 0xfa, 0xac, 0x72, 0xa7, 0x8a, 0xd1, 0x0a, 0x81,
	0x8e, 0xb6, 0x92, 0x89, 0xd1, 0xc6, 0xd9, 0x6f, 0xf2, 0x90, 0xb3, 0x40, 0xee, 0xd4, 0x2e, 0xb5,
	0x29, 0x50, 0xb2, 0x0b, 0x4d, 0xd4, 0x4c, 0x7b, 0xa2, 0xcc, 0xac, 0xea, 0x41, 0xb5, 0x1d, 0x24,
	0xd5, 0x0d, 0x61, 0xc3, 0x63, 0x82, 0x2f, 0xc6, 0x02, 0x33, 0x61, 0xba, 0xc0, 0x6d, 0x42, 0x5d,
	0xbc, 0x2d, 0xc3, 0x6e, 0x25, 0x8a, 0x8c, 0x39, 0xbd, 0xc0, 0x42, 0x9b, 0x55, 0x6a, 0x6a, 0x89,
	0x92, 0x9b, 0xd0, 0x44, 0xaf, 0x2a, 0x45, 0x9a, 0x9e, 0x7a, 0x70, 0xff, 0xd9, 0x80, 0xde, 0x7e,
	0x98, 0xa5, 0x54, 0xf8, 0xb3, 0xa7, 0x49, 0xc0, 0xbe, 0x57, 0x8e, 0xed, 0x02, 0xe4, 0x3c, 0xf2,
	0xd8, 0x4b, 0x1e, 0x0a, 0x9d, 0x1f, 0xa4, 0x28, 0x7d, 0xf0, 0xdc, 0x3b, 0x2c, 0x24, 0x9e, 0xc1,
	0x42, 0x05, 0xa9, 0x10, 0xfc, 0x29, 0xc6, 0x50, 0xdd, 0xf0, 0x49, 0x89, 0x92, 0xcf, 0xa0, 0x7b,
	0x5e, 0x1a, 0x25, 0x73, 0x1a, 0xd2, 0x5e, 0xe4, 0x0a, 0x7b, 0x99, 0x34, 0xf2, 0x21, 0x34, 0x7d,
	0xea, 0xcf, 0x58, 0x51, 0xf1, 0x36, 0xca, 0xca, 0x85, 0xa0, 0xa7, 0x64, 0xe4, 0xe7, 0xd0, 0x0b,
	0xd8, 0x29, 0xcd, 0x23, 0x21, 0x83, 0xbf, 0xa8, 0x72, 0xcb, 0xea, 0x58, 0xe6, 0x9e, 0x54, 0xca,
	0xf2, 0x2a, 0x6c, 0x0c, 0xa8, 0x3c, 0x63, 0xfb, 0x0a, 0x92, 0x95, 0x4e, 0xbb, 0xd9, 0xc0, 0x91,
	0x75, 0x82, 0x56, 0x3c, 0x90, 0xd1, 0xdd, 0x36, 0x7c, 0x60, 0xe0, 0xe4, 0x0b, 0xd8, 0xe0, 0xa6,
	0x6b, 0x9d, 0x8e, 0x54, 0xe5, 0x56, 0x19, 0xd5, 0xa6, 0xd0, 0xab, 0x72, 0xb1, 0xd3, 0x4a, 0x63,
	0xea, 0x4e, 0x0b, 0x66, 0xa7, 0x35, 0x25, 0xe4, 0x3e, 0x74, 0x39, 0xa3, 0x81, 0x26, 0x76, 0x0d,
	0xa2, 0x29, 0xc0, 0xfc, 0x9a, 0x25, 0x99, 0x90, 0xf9, 0xd5, 0xab, 0xe6, 0xd7, 0x93, 0x02, 0xd7,
	0x7e, 0xd2, 0x3c, 0x3c, 0xa8, 0x8f, 0x91, 0x30, 0x47, 0x86, 0xb3, 0x61, 0xe6, 0xd7, 0x12, 0x77,
	0xff, 0x64, 0x41, 0x53, 0xfa, 0x80, 0x7c, 0x0c, 0x8d, 0x33, 0xb6, 0xc8, 0x64, 0x51, 0x7c, 0x4b,
	0x56, 0x49, 0x12, 0x86, 0x49, 0xc0, 0x68, 0x10, 0x85, 0x31, 0xab, 0x96, 0x6f, 0x8d, 0x92, 0x9f,
	0x00, 0xf8, 0x49, 0x1c, 0x84, 0x2a, 0x4a, 0x56, 0xea, 0xdb, 0x50, 0x4b, 0x4a, 0x8d, 0x4a, 0xaa,
	0xfb, 0x4b, 0xd8, 0xf4, 0x58, 0x1c, 0x30, 0x3e, 0x61, 0xf3, 0x34, 0x52, 0xf3, 0xc5, 0x7a, 0x72,
	0xf2, 0x0d, 0xf3, 0x85, 0x56, 0xee, 0xe6, 0xd2, 0x0d, 0x48, 0x3c, 0x96, 0x42, 0x4f, 0x93, 0xdc,
	0x73, 0xe8, 0x99, 0x82, 0xb7, 0xd4, 0xc4, 0x1d, 0x68, 0x62, 0x5c, 0xeb, 0x62, 0x4d, 0xaa, 0xef,
	0x1d, 0x08, 0xc1, 0x3d, 0x45, 0xc0, 0x7c, 0x3b, 0x8d, 0xa8, 0x18, 0x48, 0x76, 0xdd, 0x88, 0xad,
	0x25, 0xec, 0x1e, 0x02, 0x2c, 0x17, 0xbe, 0x65, 0x57, 0x59, 0xf9, 0x04, 0xa7, 0xbe, 0x78, 0x74,
	0x91, 0xae, 0x56, 0x3e, 0x8d, 0xbb, 0x7f, 0x68, 0x43, 0x7d, 0x30, 0x3a, 0xb8, 0xe6, 0x30, 0xab,
	0x72, 0x7f, 0x44, 0x85, 0x60, 0x3c, 0x2e, 0x32, 0xd9, 0xcc, 0xfd, 0x42, 0xe2, 0x19, 0x2c, 0x39,
	0xb8, 0x30, 0x31, 0x4b, 0x02, 0xd9, 0x64, 0x3a, 0xe5, 0xe0, 0x22, 0x31, 0x94, 0x06, 0xc9, 0x9c,
	0x86, 0x6a, 0xe8, 0x2a, 0xa5, 0x0a, 0x93, 0xdd, 0x45, 0x50, 0x91, 0x67, 0x32, 0x69, 0xcd, 0xee,
	0x22, 0xd1, 0xb2, 0xbb, 0xc8, 0x27, 0xf2, 0x2b, 0xd8, 0x0a, 0xd3, 0x4a, 0x63, 0x96, 0xf9, 0xda,
	0x5d, 0x8e, 0x1c, 0x2b, 0x7d, 0x7b, 0xef, 0x03, 0x4c, 0xf8, 0xd7, 0xaf, 0xee, 0xae, 0x36, 0x74,
	0x6f, 0xf5, 0x45, 0x97, 0x8a, 0x48, 0xfb, 0x9d, 0x8a, 0x48, 0x1f, 0x9a, 0xb1, 0x2c, 0xbf, 0x9d,
	0x6a, 0xa4, 0x99, 0xc5, 0xd7, 0x53, 0x14, 0x2c, 0xd5, 0x29, 0xe3, 0xf3, 0xcc, 0x01, 0x39, 0x29,
	0xa8, 0x07, 0xf4, 0x2e, 0xcd, 0xc5, 0xec, 0xcb, 0x30, 0xc2, 0x1e, 0xd5, 0x35, 0xbd, 0xbb, 0xc4,
	0x71, 0xa4, 0xe3, 0x95, 0x28, 0x97, 0x79, 0x6d, 0x34, 0x9e, 0x6a, 0x0e, 0x78, 0x2b, 0xec, 0x95,
	0x62, 0xb7, 0xf1, 0x86, 0x62, 0xf7, 0x39, 0x74, 0xe6, 0xa8, 0x35, 0xf6, 0x2e, 0x67, 0x53, 0x3a,
	0xa6, 0xcc, 0xc1, 0x23, 0x2d, 0xd0, 0x81, 0x5c, 0x32, 0x31, 0xbb, 0xd3, 0x24, 0x93, 0xf9, 0xe8,
	0x6c, 0xdd, 0xb3, 0x76, 0x36, 0xca, 0x19, 0xb7, 0x40, 0xc9, 0x8f, 0xa0, 0x21, 0xe8, 0x34, 0x73,
	0xec, 0x37, 0xcd, 0x2d, 0x52, 0x4c, 0xf6, 0xc1, 0x7e, 0xc9, 0x4e, 0xc6, 0x89, 0x7f, 0xc6, 0x8a,
	0x21, 0x31, 0x73, 0x6e, 0xc8, 0x73, 0x3a, 0x7a, 0xc9, 0x8b, 0x15, 0xb9, 0x77, 0x69, 0x85, 0x31,
	0x50, 0x93, 0x2b, 0x06, 0xea, 0xcb, 0xc3, 0xf1, 0x7b, 0xef, 0x34, 0x1c, 0x5f, 0x31, 0xfe, 0xde,
	0xbc, 0xce, 0xf8, 0x8b, 0x6a, 0xe6, 0x19, 0x9b, 0x1c, 0x8e, 0x9d, 0x5b, 0x86, 0x3b, 0x0a, 0x8c,
	0xfc, 0x14, 0x7a, 0x22, 0xca, 0x1e, 0xcd, 0x4f, 0x58, 0x30, 0x64, 0x5c, 0x38, 0xef, 0x4b, 0x25,
	0xcb, 0xf8, 0x9a, 0x1c, 0x8e, 0x4b, 0x99, 0x57, 0x61, 0xba, 0x23, 0xe8, 0x99, 0x52, 0xf4, 0x8e,
	0xcf, 0xb8, 0xd8, 0xa7, 0x82, 0xaa, 0xd9, 0xb3, 0x08, 0xe4, 0x12, 0xc5, 0xdb, 0xe1, 0x19, 0x5b,
	0x48, 0x42, 0xcd, 0x20, 0x68, 0xd0, 0xfd, 0xbd, 0x05, 0x9d, 0xb2, 0x04, 0x5f, 0x77, 0xa6, 0xfa,
	0x10, 0xea, 0xfe, 0x3c, 0x2d, 0x86, 0xc9, 0x6e, 0x69, 0xec, 0xa3, 0x51, 0x41, 0x45, 0x29, 0xda,
	0x84, 0x5d, 0xa4, 0xcc, 0x17, 0x95, 0x61, 0xa2, 0xc0, 0xdc, 0xbf, 0xd7, 0x60, 0xdd, 0x4b, 0x72,
	0x11, 0xc6, 0xd3, 0xb7, 0x96, 0xb9, 0xca, 0xb0, 0x53, 0xbb, 0x7a, 0xd8, 0xb9, 0x6e, 0xbf, 0x21,
	0x0f, 0xa1, 0x9d, 0xe9, 0x2e, 0xdf, 0x58, 0x71, 0xbc, 0xd2, 0x4d, 0x37, 0xf6, 0xf2, 0x8a, 0xa2,
	0x1b, 0xfd, 0x7d, 0xe8, 0x0a, 0xe3, 0x92, 0x6c, 0x5e, 0x46, 0x4d, 0xc1, 0x3b, 0x16, 0xc7, 0x1f,
	0x40, 0x9d, 0xa6, 0xa1, 0x2c, 0x88, 0x8d, 0xbd, 0x6e, 0x61, 0x0a, 0x6c, 0x05, 0x1e, 0xe2, 0x65,
	0xcd, 0x6f, 0xaf, 0xd6, 0x7c, 0xf7, 0xc7, 0x60, 0xbf, 0xb8, 0x22, 0x77, 0x12, 0x1e, 0x4e, 0xc3,
	0xb8, 0xd2, 0x87, 0x0a, 0xcc, 0x7d, 0x08, 0xad, 0xf1, 0x02, 0x67, 0x01, 0xf2, 0x29, 0x8e, 0x9d,
	0x79, 0x2c, 0x8a, 0x00, 0x78, 0x6f, 0x69, 0xb9, 0x3c, 0x16, 0x47, 0x4c, 0xf0, 0xd0, 0xd7, 0xc3,
	0xaf, 0xe4, 0xb9, 0xff, 0xb0, 0xa0, 0x6b, 0x08, 0x31, 0xe6, 0x0a, 0x67, 0x54, 0xbe, 0x2c, 0x68,
	0x10, 0x15, 0x51, 0x57, 0x3b, 0xe9, 0xc0, 0x32, 0x89, 0x15, 0xa6, 0xcf, 0xac, 0x3e, 0x1b, 0x5c,
	0x3e, 0xf3, 0x36, 0xac, 0x73, 0xe5, 0x8b, 0xea, 0xe7, 0x8e, 0x02, 0xc4, 0x97, 0xa7, 0x51, 0x3e,
	0x2d, 0x7a, 0x53, 0xf9, 0x72, 0x85, 0x91, 0x3e, 0x6c, 0xd0, 0x34, 0x8d, 0x42, 0x16, 0x8c, 0x14,
	0xa9, 0x65, 0x7e, 0x58, 0xa9, 0x88, 0xdc, 0xbf, 0xd5, 0xa0, 0xa5, 0xfe, 0x5e, 0xb3, 0xf1, 0xde,
	0x81, 0x16, 0x96, 0xf9, 0x84, 0x57, 0x23, 0x5e, 0x61, 0x78, 0xad, 0x62, 0x73, 0x1a, 0x46, 0x95,
	0x0e, 0xab, 0x20, 0x23, 0x4a, 0x9a, 0xdf, 0x23, 0x4a, 0xee, 0x41, 0x3b, 0x4f, 0x03, 0x2a, 0xd8,
	0x40, 0x54, 0xce, 0x53, 0xa2, 0x68, 0xb4, 0x73, 0xc6, 0xe5, 0xed, 0xca, 0xbc, 0xf6, 0x6b, 0x90,
	0x7c, 0x02, 0x0d, 0x81, 0x03, 0xa5, 0xba, 0xec, 0x97, 0x0d, 0x52, 0x9d, 0xde, 0x18, 0x29, 0x25,
	0x8b, 0x38, 0x78, 0x59, 0x8d, 0x05, 0x8b, 0x85, 0x9c, 0x85, 0x7b, 0x9e, 0x7e, 0x24, 0x36, 0xd4,
	0xfd, 0xd3, 0xa9, 0x9c, 0x72, 0x7b, 0x1e, 0xfe, 0x75, 0x0f, 0x61, 0x73, 0x60, 0x5a, 0x35, 0x7b,
	0xab, 0x2d, 0xb7, 0x01, 0x0a, 0x1f, 0x1c, 0xec, 0xab, 0x49, 0xac, 0xe1, 0x19, 0x48, 0xff, 0x23,
	0x68, 0x29, 0x0b, 0x90, 0x36, 0x34, 0xf6, 0x93, 0x97, 0xb1, 0xbd, 0x46, 0x5a, 0x50, 0x7b, 0x9e,
	0xda, 0x16, 0xe9, 0xc2, 0xfa, 0xf3, 0xf8, 0x2c, 0x46, 0xb0, 0xd6, 0x7f, 0x00, 0x1b, 0x45, 0xad,
	0x5f, 0xf2, 0x8f, 0x53, 0x86, 0xfc, 0x36, 0x34, 0x9e, 0xd0, 0xe8, 0xd4, 0xb6, 0x48, 0x07, 0x9a,
	0xf2, 0x7b, 0x92, 0x5d, 0xeb, 0x0f, 0xa1, 0x6b, 0x7c, 0xd5, 0x23, 0x9b, 0x00, 0x5e, 0x92, 0xc7,
	0x81, 0x97, 0x9c, 0x84, 0xb8, 0x06, 0xa0, 0x75, 0x30, 0x7a, 0x42, 0xb3, 0x99, 0x6d, 0xa1, 0xec,
	0x45, 0x38, 0x9d, 0x09, 0x25, 0xab, 0xe1, 0xfb, 0x3c, 0x1a, 0x07, 0x76, 0xbd, 0xff, 0x33, 0x68,
	0xeb, 0x2f, 0x41, 0x72, 0x97, 0xc9, 0x64, 0xa4, 0xf6, 0x7b, 0xcc, 0x53, 0x5f, 0xed, 0xb7, 0x9f,
	0x9f, 0x9c, 0x24, 0x76, 0x8d, 0x6c, 0x41, 0x77, 0x9c, 0xf2, 0x30, 0x9e, 0x0e, 0xa3, 0x24, 0xc7,
	0xb5, 0xbf, 0x86, 0x96, 0xba, 0x7c, 0xa3, 0xe8, 0x59, 0xce, 0xe4, 0x1d, 0x22, 0x8c, 0xa7, 0xf6,
	0x1a, 0xe9, 0x41, 0xfb, 0xcb, 0x84, 0xcf, 0xb1, 0x5c, 0xdb, 0x16, 0x3e, 0x7d, 0x35, 0x3e, 0x7e,
	0xba, 0x97, 0x04, 0x0b, 0xbb, 0x86, 0x8a, 0x3d, 0x91, 0x9f, 0x10, 0xec, 0x3a, 0xfe, 0x1f, 0xca,
	0x2f, 0x04, 0x76, 0x83, 0x6c, 0x40, 0x67, 0x44, 0xc5, 0x4c, 0x36, 0x60, 0xbb, 0xd9, 0xbf, 0x0d,
	0x6d, 0x7d, 0xf9, 0x96, 0x67, 0xcb, 0x23, 0xe6, 0xb1, 0x29, 0xbb, 0x48, 0xed, 0xb5, 0xfe, 0x73,
	0xa8, 0x0f, 0x8f, 0x46, 0xd2, 0x18, 0x47, 0xa3, 0x47, 0xcf, 0xec, 0xb5, 0xe2, 0xef, 0xe1, 0xa4,
	0x30, 0xd1, 0xd1, 0xe8, 0xf0, 0x91, 0x5d, 0x2b, 0xfe, 0x3e, 0x9e, 0xd8, 0x75, 0xfd, 0xf7, 0x91,
	0xdd, 0x28, 0xfe, 0x1e, 0xc4, 0x76, 0x13, 0x35, 0x1b, 0x1e, 0x8d, 0xe4, 0x2c, 0x61, 0xb7, 0xfa,
	0xf7, 0x61, 0x6b, 0xa5, 0x66, 0xa2, 0x25, 0x86, 0x49, 0xba, 0x50, 0x3b, 0x8c, 0xd3, 0x28, 0x14,
	0xb6, 0xd5, 0x7f, 0x08, 0x9d, 0x72, 0xfc, 0x20, 0x36, 0xf4, 0xe4, 0x43, 0x31, 0xb4, 0xa8, 0xc3,
	0x4b, 0x64, 0x10, 0x45, 0xea, 0xf0, 0xea, 0x29, 0x5e, 0xd8, 0xb5, 0xfe, 0x00, 0xda, 0xfa, 0xca,
	0x83, 0xa7, 0xc2, 0xff, 0xc7, 0xb2, 0x98, 0xd9, 0x6b, 0xe4, 0x16, 0xdc, 0xc0, 0x67, 0xf5, 0xc5,
	0x6f, 0x10, 0x04, 0x9c, 0x65, 0x99, 0x72, 0x1e, 0xc2, 0xc3, 0x3c, 0x13, 0xc9, 0xdc, 0xae, 0xf5,
	0x3f, 0x82, 0xad, 0x95, 0x96, 0x8e, 0x5a, 0xbe, 0xa0, 0xa1, 0x50, 0x5e, 0xf7, 0x18, 0x5e, 0x1b,
	0x6c, 0xab, 0x7f, 0x07, 0x60, 0x99, 0x0d, 0xf8, 0x9a, 0xaf, 0xe8, 0x39, 0x1d, 0xfb, 0x3c, 0x4c,
	0x85, 0xbd, 0xb6, 0x77, 0xf3, 0xbb, 0x7f, 0x6f, 0xaf, 0x7d, 0xfb, 0x7a, 0xdb, 0xfa, 0xee, 0xf5,
	0xb6, 0xf5, 0xaf, 0xd7, 0xdb, 0xd6, 0x5f, 0xfe, 0xb3, 0xbd, 0xf6, 0xbf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xc8, 0x5c, 0x9e, 0x49, 0xf6, 0x16, 0x00, 0x00,
}

func (m *Proxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AddrRPC)))
	i += copy(dAtA[i:], m.AddrRPC)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeathCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeathCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CheckInterval))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CircuitBreaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreaker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CloseTimeout))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.HalfTrafficRate))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RateCheckPeriod))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.FailureRateToClose))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Server) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Protocol))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.HeathCheck.Size()))
		n1, err1 := m.HeathCheck.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.CircuitBreaker != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CircuitBreaker.Size()))
		n2, err2 := m.CircuitBreaker.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Weight))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RateLimitOption))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PairValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PairValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IPAccessControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAccessControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cookies) > 0 {
		for _, msg := range m.Cookies {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Code))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidationRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RuleType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expression)))
	i += copy(dAtA[i:], m.Expression)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Validation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n3, err3 := m.Parameter.MarshalTo(dAtA[i:])
	if err3 != nil {
		return 0, err3
	}
	i += n3
	dAtA[i] = 0x10
	i++
	if m.Required {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RetryStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryStrategy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Interval))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MaxTimes))
	if len(m.Codes) > 0 {
		for _, num := range m.Codes {
			dAtA[i] = 0x18
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DispatchNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.URLRewrite)))
	i += copy(dAtA[i:], m.URLRewrite)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AttrName)))
	i += copy(dAtA[i:], m.AttrName)
	if len(m.Validations) > 0 {
		for _, msg := range m.Validations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cache != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Cache.Size()))
		n4, err4 := m.Cache.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DefaultValue.Size()))
		n5, err5 := m.DefaultValue.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	dAtA[i] = 0x38
	i++
	if m.UseDefault {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.BatchIndex))
	if m.RetryStrategy != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RetryStrategy.Size()))
		n6, err6 := m.RetryStrategy.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.WriteTimeout))
	dAtA[i] = 0x58
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ReadTimeout))
	dAtA[i] = 0x60
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.HostType))
	dAtA[i] = 0x6a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.CustemHost)))
	i += copy(dAtA[i:], m.CustemHost)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cache) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Deadline))
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderTemplate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Attrs) > 0 {
		for _, msg := range m.Attrs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	if m.FlatAttrs {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderAttr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.ExtractExp)))
	i += copy(dAtA[i:], m.ExtractExp)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *API) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *API) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.URLPattern)))
	i += copy(dAtA[i:], m.URLPattern)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Method)))
	i += copy(dAtA[i:], m.Method)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	if m.IPAccessControl != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.IPAccessControl.Size()))
		n7, err7 := m.IPAccessControl.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DefaultValue.Size()))
		n8, err8 := m.DefaultValue.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Perms) > 0 {
		for _, s := range m.Perms {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AuthFilter)))
	i += copy(dAtA[i:], m.AuthFilter)
	if m.RenderTemplate != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RenderTemplate.Size()))
		n9, err9 := m.RenderTemplate.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	dAtA[i] = 0x68
	i++
	if m.UseDefault {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MatchRule))
	dAtA[i] = 0x78
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Position))
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WebSocketOptions != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WebSocketOptions.Size()))
		n10, err10 := m.WebSocketOptions.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MaxQPS))
	if m.CircuitBreaker != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CircuitBreaker.Size()))
		n11, err11 := m.CircuitBreaker.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RateLimitOption))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	if m.UseTLS {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.TlsEmbedCert != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.TlsEmbedCert.Size()))
		n12, err12 := m.TlsEmbedCert.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSEmbedCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSEmbedCert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CertData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.CertData)))
		i += copy(dAtA[i:], m.CertData)
	}
	if m.KeyData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.KeyData)))
		i += copy(dAtA[i:], m.KeyData)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n13, err13 := m.Parameter.MarshalTo(dAtA[i:])
	if err13 != nil {
		return 0, err13
	}
	i += n13
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Cmp))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expect)))
	i += copy(dAtA[i:], m.Expect)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Routing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Routing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Strategy))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.TrafficRate))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x38
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.API))
	dAtA[i] = 0x42
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebSocketOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSocketOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Origin)))
	i += copy(dAtA[i:], m.Origin)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *System) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *System) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Count.Size()))
	n14, err14 := m.Count.MarshalTo(dAtA[i:])
	if err14 != nil {
		return 0, err14
	}
	i += n14
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CountMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Cluster))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Server))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.API))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Routing))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Plugin))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.AppliedPlugin))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Plugin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plugin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Author)))
	i += copy(dAtA[i:], m.Author)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Email)))
	i += copy(dAtA[i:], m.Email)
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.UpdateAt))
	dAtA[i] = 0x38
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	if m.Content != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Cfg != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Cfg)))
		i += copy(dAtA[i:], m.Cfg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AppliedPlugins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppliedPlugins) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	if len(m.AppliedIDs) > 0 {
		for _, num := range m.AppliedIDs {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Proxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.AddrRPC)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeathCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Body)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.CheckInterval))
	n += 1 + sovMetapb(uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CircuitBreaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.CloseTimeout))
	n += 1 + sovMetapb(uint64(m.HalfTrafficRate))
	n += 1 + sovMetapb(uint64(m.RateCheckPeriod))
	n += 1 + sovMetapb(uint64(m.FailureRateToClose))
	n += 1 + sovMetapb(uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Server) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Protocol))
	n += 1 + sovMetapb(uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		l = m.HeathCheck.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 1 + sovMetapb(uint64(m.Weight))
	n += 1 + sovMetapb(uint64(m.RateLimitOption))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	n += 1 + sovMetapb(uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PairValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPAccessControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Cookies) > 0 {
		for _, e := range m.Cookies {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Code))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Parameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Source))
	n += 1 + sovMetapb(uint64(m.Index))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidationRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.RuleType))
	l = len(m.Expression)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Validation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 2
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.Interval))
	n += 1 + sovMetapb(uint64(m.MaxTimes))
	if len(m.Codes) > 0 {
		for _, e := range m.Codes {
			n += 1 + sovMetapb(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DispatchNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	l = len(m.URLRewrite)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.AttrName)
	n += 1 + l + sovMetapb(uint64(l))
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Cache != nil {
		l = m.Cache.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 2
	n += 1 + sovMetapb(uint64(m.BatchIndex))
	if m.RetryStrategy != nil {
		l = m.RetryStrategy.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 1 + sovMetapb(uint64(m.WriteTimeout))
	n += 1 + sovMetapb(uint64(m.ReadTimeout))
	n += 1 + sovMetapb(uint64(m.HostType))
	l = len(m.CustemHost)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Deadline))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.ExtractExp)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *API) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.URLPattern)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Method)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Status))
	if m.IPAccessControl != nil {
		l = m.IPAccessControl.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Perms) > 0 {
		for _, s := range m.Perms {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	l = len(m.AuthFilter)
	n += 1 + l + sovMetapb(uint64(l))
	if m.RenderTemplate != nil {
		l = m.RenderTemplate.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 2
	n += 1 + sovMetapb(uint64(m.MatchRule))
	n += 1 + sovMetapb(uint64(m.Position))
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if m.WebSocketOptions != nil {
		l = m.WebSocketOptions.Size()
		n += 2 + l + sovMetapb(uint64(l))
	}
	n += 2 + sovMetapb(uint64(m.MaxQPS))
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 2 + l + sovMetapb(uint64(l))
	}
	n += 2 + sovMetapb(uint64(m.RateLimitOption))
	n += 3
	if m.TlsEmbedCert != nil {
		l = m.TlsEmbedCert.Size()
		n += 2 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSEmbedCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CertData != nil {
		l = len(m.CertData)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.KeyData != nil {
		l = len(m.KeyData)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Cmp))
	l = len(m.Expect)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Routing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	n += 1 + sovMetapb(uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Strategy))
	n += 1 + sovMetapb(uint64(m.TrafficRate))
	n += 1 + sovMetapb(uint64(m.Status))
	n += 1 + sovMetapb(uint64(m.API))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSocketOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Origin)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *System) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Count.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CountMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.Cluster))
	n += 1 + sovMetapb(uint64(m.Server))
	n += 1 + sovMetapb(uint64(m.API))
	n += 1 + sovMetapb(uint64(m.Routing))
	n += 1 + sovMetapb(uint64(m.Plugin))
	n += 1 + sovMetapb(uint64(m.AppliedPlugin))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plugin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Author)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Email)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Status))
	n += 1 + sovMetapb(uint64(m.UpdateAt))
	n += 1 + sovMetapb(uint64(m.Version))
	n += 1 + sovMetapb(uint64(m.Type))
	if m.Content != nil {
		l = len(m.Content)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Cfg != nil {
		l = len(m.Cfg)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppliedPlugins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	if len(m.AppliedIDs) > 0 {
		for _, e := range m.AppliedIDs {
			n += 1 + sovMetapb(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalance", wireType)
			}
			m.LoadBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalance |= LoadBalance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeathCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeathCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeathCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckInterval", wireType)
			}
			m.CheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitBreaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitBreaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTimeout", wireType)
			}
			m.CloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalfTrafficRate", wireType)
			}
			m.HalfTrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HalfTrafficRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateCheckPeriod", wireType)
			}
			m.RateCheckPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateCheckPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureRateToClose", wireType)
			}
			m.FailureRateToClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureRateToClose |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceedRateToOpen", wireType)
			}
			m.SucceedRateToOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SucceedRateToOpen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= Protocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQPS", wireType)
			}
			m.MaxQPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQPS |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeathCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeathCheck == nil {
				m.HeathCheck = &HeathCheck{}
			}
			if err := m.HeathCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitOption", wireType)
			}
			m.RateLimitOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimitOption |= RateLimitOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PairValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PairValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PairValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAccessControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAccessControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = append(m.Whitelist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blacklist = append(m.Blacklist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &PairValue{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookies = append(m.Cookies, &PairValue{})
			if err := m.Cookies[len(m.Cookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= Source(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleType", wireType)
			}
			m.RuleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleType |= RuleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, ValidationRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Codes = append(m.Codes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetapb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetapb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Codes) == 0 {
					m.Codes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Codes = append(m.Codes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, &Validation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cache == nil {
				m.Cache = &Cache{}
			}
			if err := m.Cache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &HTTPResult{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseDefault = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			m.BatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryStrategy == nil {
				m.RetryStrategy = &RetryStrategy{}
			}
			if err := m.RetryStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimeout", wireType)
			}
			m.WriteTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimeout", wireType)
			}
			m.ReadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostType", wireType)
			}
			m.HostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostType |= HostType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustemHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustemHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Parameter{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &RenderObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &RenderAttr{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatAttrs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlatAttrs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtractExp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtractExp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *API) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: API: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: API: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAccessControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAccessControl == nil {
				m.IPAccessControl = &IPAccessControl{}
			}
			if err := m.IPAccessControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &HTTPResult{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &DispatchNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenderTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RenderTemplate == nil {
				m.RenderTemplate = &RenderTemplate{}
			}
			if err := m.RenderTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseDefault = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRule", wireType)
			}
			m.MatchRule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchRule |= MatchRule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &PairValue{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebSocketOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebSocketOptions == nil {
				m.WebSocketOptions = &WebSocketOptions{}
			}
			if err := m.WebSocketOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQPS", wireType)
			}
			m.MaxQPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQPS |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitOption", wireType)
			}
			m.RateLimitOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimitOption |= RateLimitOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseTLS = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsEmbedCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsEmbedCert == nil {
				m.TlsEmbedCert = &TLSEmbedCert{}
			}
			if err := m.TlsEmbedCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSEmbedCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSEmbedCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSEmbedCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertData = append(m.CertData[:0], dAtA[iNdEx:postIndex]...)
			if m.CertData == nil {
				m.CertData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyData = append(m.KeyData[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyData == nil {
				m.KeyData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmp", wireType)
			}
			m.Cmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmp |= CMP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Routing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Routing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Routing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= RoutingStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficRate", wireType)
			}
			m.TrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field API", wireType)
			}
			m.API = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.API |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSocketOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSocketOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSocketOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *System) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: System: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: System: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Count.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			m.Cluster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cluster |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field API", wireType)
			}
			m.API = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.API |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			m.Routing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Routing |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			m.Plugin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plugin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedPlugin", wireType)
			}
			m.AppliedPlugin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedPlugin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plugin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plugin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plugin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PluginType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cfg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cfg = append(m.Cfg[:0], dAtA[iNdEx:postIndex]...)
			if m.Cfg == nil {
				m.Cfg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppliedPlugins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppliedPlugins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppliedPlugins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AppliedIDs = append(m.AppliedIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetapb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetapb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AppliedIDs) == 0 {
					m.AppliedIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AppliedIDs = append(m.AppliedIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMetapb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)
